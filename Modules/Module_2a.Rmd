---
title: 'Module 2a: Random Number Generation'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE, warning  = TRUE)
knitr::opts_knit$set(root.dir = '../')
```
# Random Number Generation
R provides a number of pseudo-random number functions that generate sequences 
of numbers from various well-known probability distributions. Random number 
functions use a parameter, referred to as the seed, which specifies a 
starting point of the random number stream (thus computer generated random 
number sequences are pseudo-random). When the seed is not specified, the 
computer generates a starting value, A different seed is generated every 
time you run a random function. To specify a seed value, you use the built-in 
function set.seed() prior to running the random number function. 
For reproducible results, you will need to set
the seed before every random function. Note that setting the same seed will 
produce two identical distributions if the function is the same. In module 1a, 
we used the sample function to generate 2 vectors - one for gender and one 
for smokers to demonstrate tables. Note that if the same seed had been used
in both instances (as below) - all of our females would have been smokers and 
all of our males would have been non-smokers. 

```{r}
# data frame with Gender and Smoking Status Randomly assigned
set.seed(123)
Gender <- sample(c('Female', 'Male'), 50, replace = T)
set.seed(123)
Smoker <- sample(c('Smoker', 'NonSmoker'), 50, replace = T)
df5 <- data.frame(Gender, Smoker)
# look at Smoking Status by Gender
table(df5$Gender, df5$Smoker)
```
If the seed had not been set a second time, the computer would've generated a 
seed and the results would've been essentially impossible to reproduce. 
Note: The same seed will not always produce the identical distribution on 
different machines and/or operating systems.  

Each sequence of random numbers generated by R functions will have the 
characteristics of the probability distribution from which it was selected.  

## The uniform distribuition  
The runif() function generates random numbers in a uniform distribution. The
runif() function accepts arguments for the number of numbers generated (n) and 
the minimum (min) and maximum (max) values. n is required, the default min = 0 
and max = 1. 

```{r}
set.seed(15)
uniform <- runif(n = 100) # generate 100 numbers in a uniform distribution with
# min = 0 and max = 1
head(uniform)
```

```{r, eval = F}
# for more information on the uniform distribution and its associated functions
# in R
?Uniform
```

Recall that a sample of numbers from a Uniform (0,1) distribution has the 
following theoretical characteristics:  
    1. All numbers fall between the values 0 and 1  
    2. Mean of the sample is 0.5  
    3. The standard deviation is sqrt(1/12) = 0.29  

There are many tools available to explore data in R. Here we will look at using
the describe function in the psych package to examine our vector. 

```{r, eval = F}
# only needs to be run once
install.packages('psych')
```

```{r}
library(psych)
describe(uniform)
```

Now lets look at some plots of our distribution. 

```{r, fig.asp = 0.4}
par(mfrow = c(1,3)) # causes all 3 plots to be plotted side by side
hist(uniform) # generate a histogram of our vector
boxplot(uniform) # generate a box plot
qqnorm(uniform) # generate a qqplot
```

Is this what you were expecting? What about if we increase n to 100,000?

```{r, fig.asp = 0.4}
set.seed(15)
# generate 100,000 numbers in a uniform distribution with
# min = 0 and max = 1
uniformbig <- runif(n = 100000) 
describe(uniformbig)
par(mfrow = c(1,3)) # causes all 3 plots to be plotted side by side
hist(uniformbig)
boxplot(uniformbig)
qqnorm(uniformbig)
```

## The binomial distribtuion

The Binomial distribution refers to random variables with 2 possible outcomes. 
Which of the following have binomial outcomes?  
    1. Flipping a coin  
    2. Smoking status  
    3. Age  

Actually, the question is harder than it looks. Obviously, there are only 2 
outcomes for flipping a fair coin. It would seem that smoking status has a 
binomial outcome, but what if we are interested in current, former, and never 
smokers? This would no longer be binomial. Age, if used continuously will not 
be binomial, but what if we were interested in whether or not a person is 
over 21 – then age would be considered binomial. It is critical that you have 
a clear definition of the processes you are studying, prior to any analyses.

Similar to generating random numbers from a uniform distribution, 
you can generate a series of random numbers from the binomial distribution. T
he function rbinom() is used to generate a n numbers where each number 
represents the number of successes, ‘x’, in a single binomial experiment of 
‘size’ trials and ‘p’ is the probability of a success for a single trial. 
This function requires we specify three parameters:  
    * n      = the number of observations, or sample size to generate  
    * size   = the number of trials for each observation  
    * p      = the probability of success (bounded by 0 and 1)
      
```{r}
set.seed(67)
x <- rbinom(1, 1000, 0.01)
x
```
What is x in this instance?  
It is the number of success in 1,000 trials and we would expect it to be 
close to 1000*0.01 = `r 1000*0.01` - is it?

What about if we do 4 experiments of flipping a fair coin 8 times?
```{r}
set.seed(99)
x <- rbinom(4, 8, 0.5)
x
```

```{r, eval = F}
# for more information on the binomial distribution and its associated functions
# in R
?Binomial
```

## The Poisson Distribution
The Poisson distribution represents the total number of occurrences of rare events 
in a predefined period of time, distance, etc. when the probability of an event 
occurring in a short time frame is close to zero and the probability remains 
the same for any short interval in the time observed period. It can be applied 
to events occurring in time or space and it’s characterized by one parameter, 
$\mu$, which is the mean and the variance of the distribution.  
Recall that the Poisson distribution generates count data, taking on integer 
values 0, 1, 2, 3, … How is this different from the binomial distribution? 
The range of the binomial distribution is 0, 1, 2, 3, …n. In other words, 
there is a maximum value (n) that can be attained, whereas the Poisson 
distribution can range from 0 to $\infty$ depending of the length of time the 
experiment is observed. 
rpois() requires the parameters n and lambda where n = number of random values 
to return and lambda = the average number of events that is expected to occur in
the time/space observed. 

```{r}
set.seed(0)
p <- rpois(10000, 7)
summary(p)
```

Notice that the mean of Poisson distribution is about 7, as is the variance 
( = stddev^2^).  Does the output from the summary function confirm this 
theoretical result?

```{r, eval = F}
# for more information on the Poisson distribution and its associated functions
# in R
?Poisson
```

## The Normal Distribution
The normal distribution is a continuous probability distribution and is commonly
used to represent real-valued random variables whose distributions are not 
known. rnorm() has the required argument n, and the optional arguments mean = 0, 
and sd = 1 (this means that by default, if mean and sd are not set they are 
0 and 1).

```{r}
set.seed(123)
# generate 100 numbers with mean 0 and sd = 1
normdist <- rnorm(100)
# lets get the mean, std and range of this vector
mean(normdist)
sd(normdist)
range(normdist)

# lets also look at the histogram
hist(normdist)

# we can change the look of the histrogram somewhat by modifiying the breaks
# also lets add some color and a title!
hist(normdist, breaks = seq(-3, 3, 0.1), col = 'blue', 
     main = paste0('Histogram of Randomly Generated 100 numbers from \n',  
                   'the Normal Distribution'))
```

Is this what you expected? What about if we increase n to 1000?
```{r}
set.seed(123)
# generate 100 numbers with mean 0 and sd = 1
normdist <- rnorm(1000)
# lets get the mean and std of this vector
mean(normdist)
sd(normdist)

# lets also look at the histogram
hist(normdist, breaks = seq(-3.5, 3.5, 0.1), col = 'green', 
     main = paste0('Histogram of Randomly Generated 1,000 numbers from \n ',  
                   'the Normal Distribution'))
```

```{r, eval = F}
# for more information on the normal distribution and its associated functions
# in R
?Normal
```

# Generating Stimulated Data
Repeatedly generating data samples where you know the population, and then 
looking at the samples can give you insight into the effects of random 
fluctuations. Early statisticians did this to check their mathematical results. 
Luckily for us, R can do this (called simulations) in seconds. It is a useful 
learning tool to know exactly how far to trust statistical procedures. 
Mathematical statistics tells us what happens when certain assumptions are e
exactly true. In the real word of data, nothing is ever exactly true. 
Simulations can let you see what happens when the assumptions are not met in 
various ways.

Suppose we wanted to generate some data for the weights of men and women. 
We would want to consider the following items:  

1.	Roughly half should be men and half should be women.  
2.	Our data should be normally distributed for each gender.  
3.	The data for men’s weights should be centered around a different expected value than for women’s weights and we would like for each gender to have its own different variation.  

In order to get an approximately even split between men and women; 
we can use the runif() function.
```{r}
set.seed(23)
Gender <- ifelse(runif(1000) >= 0.5, 'Female', 'Male')
# let's break that down
# The ifelse statement allows us to say if the condition is true, then return
# one value, if not (else) return the other value
# the form of the ifelse output will always be the same as that of 
# test(condition)
# so in the example above we have generated an approximately uniform 
# distribution of 1000 numbers between 0 and 1. If the number is less than 
# or equalt to 0.5 the corresponding gender value is 'Female', if not (else) it
# is male. 

# lets check it
table(Gender)
# 512 males to 488 males about a 50/50 split. 
```

In order to get normally distributed weight data we will use the rnorm() 
function. To get separate distributions for males and females, that reflect their 
gender specific means and standard deviations, we can conditionally 
specify a mean and standard deviation. For example, suppose that we would like 
to have data that reflects a) means of 180 pounds and 140 pounds; and 
b) standard deviations of 15 pounds and 11, for males and females, respectively. 

```{r}
FemaleWeights <- rnorm(n = sum(Gender == 'Female'), mean = 140, sd = 11)
# remember from module 1a we can use the sum function on a logical to
# count the number of times something is true
sum(Gender == 'Female')
# notice it is the same answer we got from the table above
```


```{r}
MaleWeights <- rnorm(n = sum(Gender == 'Male'), mean = 180, sd = 15)
# now we set the weights to the correct indeces by gender
Weight <- ifelse(Gender == 'Female', FemaleWeights, MaleWeights)
```

```{r}
# lets combine the two vectors into a data frame
NormData <- data.frame(Gender, Weight)
head(NormData)
```

# Summary Measures
We have already seen some of the summary measures (mean, sd, and range). Here we
will explore those by subgroups as well as adding a few more into the mix. 
First lets look at mean and standard deviation of weight by gender using
the aggregate function. 

```{r}
aggregate(Weight ~ Gender, data = NormData, FUN = mean)
# this code chunk uses the formula notation
# in this context it says lets look at Weight by Gender in the NormData data 
# frame
aggregate(Weight ~ Gender, data = NormData, FUN = sd)
```

Alternatively, we can use the summaryBy() function from the "doBy" package. This 
allows us to combine mean and sd into one function call. 
```{r, eval = F}
# only needs to be run once
install.packages('doBy')
```

```{r}
library(doBy)
summaryBy(Weight ~ Gender, data = NormData, FUN = c(mean, sd))
# we can also save the output as a data object 
WeightSummary <- summaryBy(Weight ~ Gender, data = NormData, FUN = c(mean, sd))
WeightSummary
# This should be close to 140 and 11 for females and 180 and 15 for males
# and it is!
```

```{r}
# you can also use print() around the assignment operator to assign and print 
# results in the same line
print(WeightSummary <- summaryBy(Weight ~ Gender, 
                                 data = NormData, 
                                 FUN = c(mean, sd)))
```

Let's also look at min, max, and median. 
```{r}
min(NormData$Weight)
max(NormData$Weight)

summaryBy(Weight ~ Gender, data = NormData, FUN = c(min, max, median))
```


## The cumulative density function
For each distribution, r has a function for determining the cumulative 
probability. For the uniform, binomial, Poisson and normal distributions, the
functions are punif(), pbinom(), ppois() and pnorm() respectively. Notice these
are the same suffixes as in the random function with r for random replaced with
p for probability. Here the argument n is replaced with q and the other required 
arguments remain the same. Therefore pnorm and punif only require n, pbinom 
requires size and prob, and ppois requires lambda. Graphically, this is the area
under the curve to the left of q. 

```{r}
pnorm(1.96)
```

```{r}
# generate normal distribtion
set.seed(100)
normdata <- rnorm(100000)
hist(normdata, breaks = seq(-4.6, 4.6, .1), 
     col = c(rep('blue', 66), rep('red', 27)), 
     main = 'The Cumulative Density of 1.96', 
     xlab = NULL)
abline(v = 1.96)
```

The inverse of this is the qunif, qbinom, qpois, and qnorm functions. 
```{r}
qnorm(.975)
```
